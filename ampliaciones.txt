Martin Fernandez Prieto, UO258619
Ampliaciones realizadas: 1, 2, 10, 4, 6 y 5.

1. Nuevos tipos de enemigos
	Creamos una nueva clase Enemigo, en la cual vamos definir el constructor donde se pase la imagen, para que cada enemigo
	pueda conservar su imagen en función del tipo de enemigo que sea. Vamos a dejar tambien el findeAnimacionMorir, el actualizar
	dibujar y impactado ya que no deberian de ser modificados, y si nos interesase podriamos sobreescribirlos directamente.
	
	class Enemigo extends Modelo {

		constructor(x, y, imagen) {
			super(imagen, x, y);
		}

		finAnimacionMorir(){
			this.estado = estados.muerto;
		}

		actualizar (){
			this.animacion.actualizar();

			switch (this.estado){
				case estados.moviendo:
					this.animacion = this.aMover;
					break;
				case estados.muriendo:
					this.animacion = this.aMorir;
					break;
			}

			if ( this.estado == estados.muriendo) {
				this.vx = 0;
			} else {
				if ( this.vx == 0){
					this.vxInteligencia = this.vxInteligencia * -1;
					this.vx = this.vxInteligencia;
				}
				if (this.fueraPorDerecha ){
					// mover hacia la izquierda vx tiene que ser negativa
					if ( this.vxInteligencia > 0){
						this.vxInteligencia = this.vxInteligencia * -1;
					}
					this.vx = this.vxInteligencia;
				}
				if (this.fueraPorIzquierda ){
					// mover hacia la derecha vx tiene que ser positiva
					if ( this.vxInteligencia < 0){
						this.vxInteligencia = this.vxInteligencia * -1;
					}
					this.vx = this.vxInteligencia;
				}
			}

		}

		dibujar (scrollX){
			scrollX = scrollX || 0;
			this.animacion.dibujar(this.x - scrollX, this.y);
		}

		impactado(){
			if ( this.estado != estados.muriendo ){
				this.estado = estados.muriendo;
			}
		}
	}
	
	Modifique en el codigo de colisiones, que si el enemigo esta muerto o muriendose no se haga la colision:
		for (var i=0; i < this.enemigos.length; i++){
            if (this.jugador.colisiona(this.enemigos[i]) && this.enemigos[i].estado != estados.muerto
                        && this.enemigos[i].estado != estados.muriendo) {
                this.jugador.golpeado();
                if (this.jugador.vidas <= 0){
                    this.iniciar();
                }
            }
        }
		
	El nuevo enemigo EnemigoDisparador.js, le cambiaremos la velocidad, imagen y añadiremos la capacidad disparar.
	Vamos a usar los recursos del campus para ahorrarnos trabajo, va a ser un cocodrilo.
	
	Añadimos el caso de que haya una D en el mapa de que cargue el nuevo tipo de enemigo:
		case "D":
			var enemigo = new EnemigoDisparador(x,y);
			enemigo.y = enemigo.y - enemigo.alto/2;
			// modificación para empezar a contar desde el suelo
			this.enemigos.push(enemigo);
			this.espacio.agregarCuerpoDinamico(enemigo);

			break;
	
	Creamos la clase Disparo que usaremos como "interfaz/clase abstracta" y crearemos los disparos basados en la primera
	practica.
	Añadimos el metodo disparar al EnemigoDisparador:
	    disparar() {
			super.disparar();
			if(this.ultimaVezIntentoDisparo == 3) {
				this.ultimaVezIntentoDisparo = 0;
				return new DisparoEnemigoDisparador(this.x, this.y);
			}
			this.ultimaVezIntentoDisparo++;
			return null;
		}
	Ahora añadiremos en el GameLayer una lista de disparos, y metodos para que cada X tiempo provoquen que los enemigos disparen:
		// Eliminar disparos ENEMIGO sin velocidad
        for (var i=0; i < this.disparosEnemigos.length; i++){
            if ( this.disparosEnemigos[i] != null &&
                this.disparosEnemigos[i].vx == 0){

                this.espacio
                    .eliminarCuerpoDinamico(this.disparosEnemigos[i]);
                this.disparosEnemigos.splice(i, 1);
            }
        }

        // Eliminar disparos ENEMIGO fuera de pantalla
        for (var i=0; i < this.disparosEnemigos.length; i++){
            if ( this.disparosEnemigos[i] != null &&
                !this.disparosEnemigos[i].estaEnPantalla()){
                this.espacio
                    .eliminarCuerpoDinamico(this.disparosEnemigos[i]);
                this.disparosEnemigos.splice(i, 1);
                i=i-1;
            }
        }

        for (var i=0; i < this.disparosEnemigos.length; i++) {
            this.disparosEnemigos[i].actualizar();
        }
		
		// colisiones , disparoEnemigo - Jugador
        for (var i=0; i < this.disparosEnemigos.length; i++){
            if (this.disparosEnemigos[i] != null &&
                this.disparosJugador[i].colisiona(this.jugador)) {

                this.espacio
                    .eliminarCuerpoDinamico(this.disparosEnemigos[i]);
                this.disparosEnemigos.splice(i, 1);
                i = i-1;
                this.jugador.golpeado();
            }
        }
		
		//ENEMIGOS DISPARAR
        for(var i=0; i < this.enemigos.length; i++) {
            if(Math.floor(Math.random() * 100) == 0 && this.enemigos[i] instanceof EnemigoDisparador) {
                var disparo = this.enemigos[i].disparar();
                if(disparo != null) {
                    this.disparosEnemigos.push(disparo);
                }
            }
        }
		
		Y ya estaria listo.
	
2. Enemigos que mueren al saltar sobre ellos
	Creamos un nuevo enemigo que sera el Koala:
	class EnemigoSaltador extends Enemigo {

		constructor(x, y) {
			super(x, y, imagenes.enemigo_saltador);
			this.estado = estados.moviendo;
			this.vxInteligencia = -1;
			this.vx = this.vxInteligencia;


			this.aMover = new Animacion(imagenes.enemigo_saltador_animacion,
				this.ancho, this.alto, 6, 8);

			this.aMorir = new Animacion(imagenes.enemigo_saltador_muriendo,
				this.ancho,this.alto,6,6, this.finAnimacionMorir.bind(this));
			// Ref a la animación actual
			this.animacion = this.aMover;

			this.vy = 0;
			this.vx = 1;
		}
	}
	
	Ahora en el GameLayer, cuando un enemigo y un jugador colisionan, tendremos que mirar que si es de tipo EnemigoSaltador, 
	si el jugador esta encima lo matara, en vez de bajarle una vida.
	Ademas tenemos que poner que se pueda generar en el mapa:
		case "S":
			var enemigo = new EnemigoSaltador(x,y);
			enemigo.y = enemigo.y - enemigo.alto/2;
			// modificación para empezar a contar desde el suelo
			this.enemigos.push(enemigo);
			this.espacio.agregarCuerpoDinamico(enemigo);

			break;
	
	Nueva funcion de las colisiones:
		// colisiones
        for (var i=0; i < this.enemigos.length; i++){
            if (this.jugador.colisiona(this.enemigos[i]) && this.enemigos[i].estado != estados.muerto
                        && this.enemigos[i].estado != estados.muriendo) {
                if(this.enemigos[i] instanceof EnemigoSaltador) {
                    if(this.enemigos[i].y > this.jugador.y + 15) {
                        this.enemigos[i].impactado();
                        this.puntos.valor++;
                    } else {
                        this.jugador.golpeado();
                        if (this.jugador.vidas <= 0) {
                            this.iniciar();
                        }
                    }
                } else {
                    this.jugador.golpeado();
                    if (this.jugador.vidas <= 0) {
                        this.iniciar();
                    }
                }
            }
        }
		
10. Tiles destruibles 2
	Creamos la clase BloqueDestruible que extiende de modelo y la declaramos en index.html
		class BloqueDestruible extends Modelo {

			constructor(rutaImagen, x, y) {
				super(rutaImagen, x, y)
			}

		}
		
	En la carga de objetos al mapa:
		case "U":
			var bloque = new BloqueDestruible(imagenes.bloque_metal, x,y);
			bloque.y = bloque.y - bloque.alto/2;
			// modificación para empezar a contar desde el suelo
			this.bloquesDestruibles.push(bloque);
			this.espacio.agregarCuerpoEstatico(bloque);
			break;
	
	El bucle for para cuando impacta un disparo del jugador:
		for (var i=0; i < this.disparosJugador.length; i++){
            for (var j=0; j < this.bloquesDestruibles.length; j++){
                if (this.disparosJugador[i] != null &&
                    this.bloquesDestruibles[j] != null &&
                    this.disparosJugador[i].colisiona(this.bloquesDestruibles[j])) {
                    this.espacio
                        .eliminarCuerpoEstatico(this.bloquesDestruibles[i]);
                    this.disparosJugador.splice(i, 1)
                    this.bloquesDestruibles.splice(i, 1);
                    j=j-1;
                    i = i-1;
                }
            }
        }
		
	Bucle para dibujarlo:
		for (var i=0; i < this.bloquesDestruibles.length; i++){
            this.bloquesDestruibles[i].dibujar(this.scrollX);
        }
	
4. Enemigo que crea enemigos
	Implementamos una nueva clase llamada EnemigoGenerador, el metodo disparar lo
	que hace es devolver un nuevo enemigo, el cual sera gestionado desde el GameLayer.
	    disparar() {
			super.disparar();
			if(this.ultimaVezIntentoDisparo == 5 && this.estado != estados.muriendo && this.estado != estados.muerto) {
				this.ultimaVezIntentoDisparo = 0;
				var random = Math.floor((Math.random() * 3)); // 0 o 1 o 2
				if(random == 0) {
					return new EnemigoBasico(this.x, this.y);
				} else if(random == 1) {
					return new EnemigoSaltador(this.x, this.y);
				} else if(random == 2) {
					return new EnemigoDisparador(this.x, this.y);
				}
			}
			this.ultimaVezIntentoDisparo++;
			return null;
		}
	
	Procesar la G en el mapa:
		case "G":
			var enemigo = new EnemigoGenerador(x,y);
			enemigo.y = enemigo.y - enemigo.alto/2;
			// modificación para empezar a contar desde el suelo
			this.enemigos.push(enemigo);
			this.espacio.agregarCuerpoDinamico(enemigo);
			break;
			
	No hace falta cambiar nada en dibujar ya que pertenece a los enemigos.
	Añadimos al bucle de los disparar la siguiente condicion:
		else if(Math.floor(Math.random() * 20) == 0 && this.enemigos[i] instanceof EnemigoGenerador) {
			var enemigo = this.enemigos[i].disparar();
			if(enemigo != null) {
				this.enemigos.push(enemigo);
				this.espacio.agregarCuerpoDinamico(enemigo);
			}
		}
		
	Cambiamos el metodo impactado, para que haga falta darle 3 veces para romper el castillo:
	    impactado(){
			this.numeroVidas--;
			if(this.numeroVidas == 0) {
				if (this.estado != estados.muriendo) {
					this.estado = estados.muriendo;
				}
			}
		}

6. Items recolectables
	Primero vamos a crear la UI para el contador de recolectables.
	Definimos lo siguiente en el iniciar() de GameLayer:
		this.recolectables = new Texto(0, 480*0.8, 320*0.07);
        this.fondoRecolectables =
            new Fondo(imagenes.icono_recolectable, 480*0.85,320*0.05);
	Y por supuesto en dibujar que dibuje.
	
	Creamos la nueva clase recolectable:
	class Recolectable extends Modelo {

		constructor(x, y) {
			super(imagenes.icono_recolectable, x, y);

			this.aMover = new Animacion(imagenes.animacion_recolectable,
				this.ancho, this.alto, 6, 8);
		}

	}
	Creamos un array de recolectables en el GameLayer, y cuando en el mapa haya
	una R creara un nuevo recolectable y lo añadira a la lista.
	Cuando el jugador impacte, desaparecera y ademas se le sumara un punto.
		case "R":
			var recolectable = new Recolectable(x,y);
			recolectable.y = recolectable.y - recolectable.alto/2;
			// modificación para empezar a contar desde el suelo
			this.recolectables.push(recolectable);
			this.espacio.agregarCuerpoDinamico(recolectable);
			break;
	Lo dibujamos:
		for(var i=0; i < this.recolectables.length; i++) {
            this.recolectables[i].dibujar(this.scrollX);
        }
		
	//Colisiones jugador con recolectable
        for(var i=0; i < this.recolectables.length; i++) {
            if(this.jugador.colisiona(this.recolectables[i])) {
                this.espacio.eliminarCuerpoDinamico(this.recolectables[i]);
                this.recolectables.splice(i, 1);
                i=i-1;
                this.recolectablesTexto.valor = this.recolectablesTexto.valor + 1;
            }
        }
		
5. Scroll en Y
	Añadimos la variable scrollY en GameLayer. En modelo modificamos el metodo estaEnPantalla
	y el metodo dibujar.
	    estaEnPantalla (){
			if ( (this.x - gameLayer.scrollX) - this.ancho/2 <= 480 &&
				(this.x - gameLayer.scrollX) + this.ancho/2 >= 0 &&
				(this.y - gameLayer.screenY) - this.alto/2 <= 320 &&
				(this.y - gameLayer.screenY) + this.alto/2 >= 0 ){
				return true;
			}
			return false;
		}


		dibujar (scrollX, scrollY){
			scrollX = scrollX || 0;
			scrollY = scrollY || 0;
			contexto.drawImage(this.imagen,
				this.x - this.ancho /2 - scrollX,
				this.y - this.alto /2 - scrollY);
		}
	El metodo de dibujar de GameLayer tendremos que pasarle a todos los objetos en el metodo
	dibujar el valor de scrollY para que lo tenga en cuenta a la hora de dibujar.
	
	Ahora ademas tendremos que modifcar el metodo calcular scroll para en funcion de eso, que
	dibuje de una manera otra.
	
	En calcular scroll ponemos lo siguiente:
		//Limite abajo, arriba no hay limite
        if (this.jugador.y < 320 * 0.7) {
            this.scrollY = this.jugador.y - 320 * 0.7;
        }
		
	Hubo problemas con algunos objetos que tuvimos que tocar metodos por que no tenia en
	cuenta el scrollY ya que sobrescribia el metodo de dibujar.
	

